<!DOCTYPE html>
<html lang="uk">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="icon" type="image/png" href="icon.png" />
  <title>Мій зоряний маяк спрацював! Вона знайшла шлях назад!</title>
  <link rel="stylesheet" href="newYear.css" />
</head>
<body>
  <div class="sunset-sun"></div>

  <div class="sun-ray" style="transform:translateX(-50%) rotate(-40deg); animation-duration:6s;"></div>
  <div class="sun-ray" style="transform:translateX(-50%) rotate(-25deg); animation-duration:8s; animation-delay:-2s;"></div>
  <div class="sun-ray" style="transform:translateX(-50%) rotate(-10deg); animation-duration:7s; animation-delay:-4s;"></div>
  <div class="sun-ray" style="transform:translateX(-50%) rotate(0deg);   animation-duration:5s; animation-delay:-1s;"></div>
  <div class="sun-ray" style="transform:translateX(-50%) rotate(10deg);  animation-duration:9s; animation-delay:-3s;"></div>
  <div class="sun-ray" style="transform:translateX(-50%) rotate(25deg);  animation-duration:7s; animation-delay:-5s;"></div>
  <div class="sun-ray" style="transform:translateX(-50%) rotate(40deg);  animation-duration:6s; animation-delay:-2s;"></div>

  <div class="horizon"></div>

  <div class="bubble" style="width:40px; height:40px; left:5%;  animation-duration:12s,3s;   animation-delay:0s,0s;"></div>
  <div class="bubble" style="width:20px; height:20px; left:15%; animation-duration:9s,2s;    animation-delay:-3s,-1s;"></div>
  <div class="bubble" style="width:55px; height:55px; left:25%; animation-duration:15s,4s;   animation-delay:-7s,-2s;"></div>
  <div class="bubble" style="width:30px; height:30px; left:38%; animation-duration:11s,2.5s; animation-delay:-2s,0s;"></div>
  <div class="bubble" style="width:18px; height:18px; left:50%; animation-duration:8s,1.8s;  animation-delay:-10s,-1s;"></div>
  <div class="bubble" style="width:45px; height:45px; left:62%; animation-duration:13s,3.5s; animation-delay:-5s,-2s;"></div>
  <div class="bubble" style="width:25px; height:25px; left:72%; animation-duration:10s,2.2s; animation-delay:-8s,-0.5s;"></div>
  <div class="bubble" style="width:60px; height:60px; left:80%; animation-duration:16s,4.5s; animation-delay:-1s,-3s;"></div>
  <div class="bubble" style="width:22px; height:22px; left:90%; animation-duration:9s,2s;    animation-delay:-4s,-1s;"></div>
  <div class="bubble" style="width:35px; height:35px; left:45%; animation-duration:14s,3s;   animation-delay:-6s,-2s;"></div>
  <div class="bubble" style="width:15px; height:15px; left:8%;  animation-duration:7s,1.5s;  animation-delay:-9s,0s;"></div>
  <div class="bubble" style="width:50px; height:50px; left:55%; animation-duration:17s,4s;   animation-delay:-12s,-2s;"></div>

  <div class="sparkle" style="left:8%;  animation-duration:10s,1.5s; animation-delay:0s,0s;    width:5px; height:5px;"></div>
  <div class="sparkle" style="left:18%; animation-duration:13s,2s;   animation-delay:-4s,-1s;  width:8px; height:8px; background:#ffa500;"></div>
  <div class="sparkle" style="left:28%; animation-duration:8s,1.2s;  animation-delay:-7s,-0.5s;width:4px; height:4px;"></div>
  <div class="sparkle" style="left:40%; animation-duration:11s,1.8s; animation-delay:-2s,-1.2s;width:7px; height:7px; background:#ffcc00;"></div>
  <div class="sparkle" style="left:52%; animation-duration:9s,1.4s;  animation-delay:-9s,-0.8s;width:5px; height:5px;"></div>
  <div class="sparkle" style="left:63%; animation-duration:14s,2.2s; animation-delay:-3s,-1.5s;width:9px; height:9px; background:#ff8c00;"></div>
  <div class="sparkle" style="left:74%; animation-duration:10s,1.6s; animation-delay:-6s,-0.3s;width:4px; height:4px;"></div>
  <div class="sparkle" style="left:85%; animation-duration:12s,1.9s; animation-delay:-1s,-1s;  width:6px; height:6px;"></div>
  <div class="sparkle" style="left:93%; animation-duration:7s,1.3s;  animation-delay:-5s,-0.7s;width:5px; height:5px;"></div>
  <div class="sparkle" style="left:33%; animation-duration:15s,2.5s; animation-delay:-8s,-1.8s;width:8px; height:8px; background:#ffd700;"></div>

  <div class="glimmer" style="left:10%; animation-duration:3s,11s;   animation-delay:0s,-2s;">✦</div>
  <div class="glimmer" style="left:30%; animation-duration:4s,14s;   animation-delay:-2s,-8s;  font-size:14px;">✦</div>
  <div class="glimmer" style="left:55%; animation-duration:2.5s,9s;  animation-delay:-1s,-5s;  font-size:22px;">✦</div>
  <div class="glimmer" style="left:78%; animation-duration:3.5s,12s; animation-delay:-3s,-3s;  font-size:16px;">✦</div>
  <div class="glimmer" style="left:92%; animation-duration:5s,16s;   animation-delay:-4s,-11s; font-size:12px;">✦</div>

  <div class="content-wrapper">
    <header>
      <h1>Мій зоряний маяк спрацював! Вона знайшла шлях назад!</h1>
    </header>

    <div class="glass-card">
      <p class="textStory">
        Я отримав від неї звістку. Усі ті місяці очікувань,
        що минали у звичних справах, миттєво залишилися в минулому.
        У листі було лише кілька слів: «Я скоро повернуся, зустрінемося в аеропорту».
        Це був пункт початку нашої нової історії.
      </p>
      <img src="images/waiting.png" alt="Очікування в аеропорту" />
    </div>

    <div class="glass-card">
      <p class="textStory">
        Я сидів у залі прильотів і слідкував за табло. Рейс затримувався,
        навколо метушився натовп, час тягнувся нестерпно повільно. І раптом,
        я побачив її. Вона була точнісінько такою ж, як у день нашого прощання.
        Коли наші погляди зустрілися, вона усміхнулася, і ця усмішка миттєво
        перекреслила всі місяці розлуки.
      </p>
      <img src="images/aeroport.png" alt="Зустріч в аеропорту" />
    </div>

    <div class="glass-card">
      <p class="textStory">
        Ми не стали витрачати часу посеред галасливого термінала.
        Без зайвих слів ми одразу поспішили додому, щоб якнайшвидше залишити натовп позаду.
        У ту мить мало значення лише одне: вона нарешті повернулася, і відстані між нами більше немає.
      </p>
      <img src="images/rush.png" alt="Розлука позаду" />
    </div>

    <div class="glass-card">
      <p class="textStory">
        Дорогою додому все здавалося трохи нереальним, ніби уві сні.
        У моїй голові крутилися сотні питань, я намагався підібрати правильні слова,
        щоб висловити все, що накопичилося за цей час. Але її спокійна присутність
        поруч робила будь-які слова зайвими. Я просто дивився на неї і розумів, що дочекався.
      </p>
      <img src="images/bus.png" alt="Подорож додому" />
    </div>

    <div class="glass-card">
      <p class="textStory">
        Коли ми дісталися нашого місця на мапі, ми не поспішали йти далі.
        Ми просто зупинилися і підняли погляди на безкрайнє зоряне небо.
        У ту хвилину ми були не просто парою звірів, а двома мандрівниками у цьому великому всесвіті.
      </p>
      <img src="images/walking.png" alt="Прогулянка під зорями" />
    </div>

    <div class="glass-card">
      <p class="textStory">
        Внизу виблискував Колізей, що нагадував древню казку. Ми уявляли, що це наш власний Колізей,
        а довкола — прекрасні сади. Ми вигадували історії про те, як дбайливо доглядаємо кожну рослину
        і як організовуємо свята для друзів та рідних. Ці фантазії були простими, але такими приємними.
        Вони наповнювали наші серця теплом і мріями про спільне майбутнє.
      </p>
      <img src="images/coliseum.png" alt="Фантазії про Колізей" />
    </div>

    <div class="glass-card">
      <p class="textStory">
        Ми сміялися і мріяли, ділячись цими простими фантазіями,
        аж поки ніч не огорнула нас абсолютною тишею. Це була ідеальна мить:
        зорі над головою, вогні Колізею внизу, мрії про сади — і ми двоє, знову поруч.
      </p>
      <img src="images/happyend.png" alt="Щасливий фінал" />
      <div class="constellation-section">
        <p class="constellation-hint" id="constellationHint">Нічне небо над Колізеєм чекає. Проведи шлях між їхніми зорями, щоб продовжити цю мить</p>
        <div class="constellation-wrap">
          <canvas id="constellationCanvas" width="360" height="280"></canvas>
        </div>
        <button id="goAnimation" class="go-btn" disabled>Кохати далі</button>
      </div>
    </div>
  </div>

  <script>
  document.addEventListener('DOMContentLoaded', () => {
    const canvas = document.getElementById('constellationCanvas');
    const ctx    = canvas.getContext('2d');
    const goBtn  = document.getElementById('goAnimation');
    const hint   = document.getElementById('constellationHint');

    // ── Responsive canvas sizing ──
    const BASE_W = 520, BASE_H = 400;   // design reference size

    function getAvailableWidth() {
      const wrap = canvas.parentElement;
      return Math.min(wrap ? wrap.clientWidth : window.innerWidth, BASE_W);
    }

    let CSS_W, CSS_H, DPR, W, H, CX, CY, SCALE;

    function initSize() {
      CSS_W  = getAvailableWidth();
      CSS_H  = Math.round(CSS_W * (BASE_H / BASE_W));  // keep aspect ratio
      DPR    = Math.min(window.devicePixelRatio || 1, 3);
      SCALE  = CSS_W / BASE_W;          // proportional scale for coordinates

      canvas.width  = CSS_W * DPR;
      canvas.height = CSS_H * DPR;
      canvas.style.width  = CSS_W + 'px';
      canvas.style.height = CSS_H + 'px';
      ctx.setTransform(1, 0, 0, 1, 0, 0); // reset
      ctx.scale(DPR, DPR);

      W  = CSS_W; H  = CSS_H;
      CX = W / 2; CY = H / 2 + 10 * SCALE;
    }

    initSize();

    // Recompute star positions based on current SCALE / CX / CY
    function buildStars() {
      const s = SCALE;
      return [
        { x: CX,          y: CY - 130*s }, //  1
        { x: CX -  68*s,  y: CY - 168*s }, //  2
        { x: CX - 148*s,  y: CY - 130*s }, //  3
        { x: CX - 185*s,  y: CY -  50*s }, //  4
        { x: CX - 160*s,  y: CY +  40*s }, //  5
        { x: CX -  90*s,  y: CY + 110*s }, //  6
        { x: CX,          y: CY + 155*s }, //  7
        { x: CX +  90*s,  y: CY + 110*s }, //  8
        { x: CX + 160*s,  y: CY +  40*s }, //  9
        { x: CX + 185*s,  y: CY -  50*s }, // 10
        { x: CX + 148*s,  y: CY - 130*s }, // 11
        { x: CX +  68*s,  y: CY - 168*s }, // 12
      ];
    }

    let STARS = buildStars();

    const HIT_BASE = 36, SR_BASE = 11;
    function HIT()  { return HIT_BASE  * SCALE; }
    function SR()   { return SR_BASE   * SCALE; }

    let nextIdx = 0, connected = [], wrongIdx = -1, wrongTimer = null;
    let done = false, fillAlpha = 0;

    function starPath(x, y, r, inner = 0.40) {
      ctx.beginPath();
      for (let i = 0; i < 10; i++) {
        const angle = (i * Math.PI / 5) - Math.PI / 2;
        const rad   = i % 2 === 0 ? r : r * inner;
        i === 0
          ? ctx.moveTo(x + Math.cos(angle)*rad, y + Math.sin(angle)*rad)
          : ctx.lineTo(x + Math.cos(angle)*rad, y + Math.sin(angle)*rad);
      }
      ctx.closePath();
    }

    function heartPath() {
      const s = SCALE;
      ctx.beginPath();
      ctx.moveTo(CX, CY - 130*s);
      ctx.bezierCurveTo(CX- 30*s, CY-190*s, CX-185*s, CY-180*s, CX-185*s, CY- 50*s);
      ctx.bezierCurveTo(CX-185*s, CY+ 40*s, CX- 90*s, CY+100*s, CX,       CY+155*s);
      ctx.bezierCurveTo(CX+ 90*s, CY+100*s, CX+185*s, CY+ 40*s, CX+185*s, CY- 50*s);
      ctx.bezierCurveTo(CX+185*s, CY-180*s, CX+ 30*s, CY-190*s, CX,       CY-130*s);
      ctx.closePath();
    }

    function drawHeartGuide(alpha) {
      ctx.save();
      heartPath();
      ctx.strokeStyle = `rgba(255,200,80,${alpha * 0.20})`;
      ctx.lineWidth   = 1.5;
      ctx.setLineDash([6, 9]);
      ctx.stroke();
      ctx.setLineDash([]);
      ctx.restore();
    }

    function drawHeartFill(alpha) {
      ctx.save();
      heartPath();
      const grad = ctx.createRadialGradient(CX, CY, 10, CX, CY, 180 * SCALE);
      grad.addColorStop(0,    `rgba(255,230,100,${alpha * 0.45})`);
      grad.addColorStop(0.45, `rgba(255,100,60, ${alpha * 0.25})`);
      grad.addColorStop(1,    `rgba(200,30,80,  ${alpha * 0.05})`);
      ctx.fillStyle = grad;
      ctx.fill();
      ctx.restore();
    }

    let BG_STARS = Array.from({ length: 50 }, () => ({
      x: Math.random() * BASE_W, y: Math.random() * BASE_H,
      r: 0.4 + Math.random() * 1.2, p: Math.random() * Math.PI * 2
    }));

    const SPARKS = Array.from({ length: 22 }, (_, i) => ({
      angle: (i / 22) * Math.PI * 2,
      dist : 85 + Math.random() * 65,
      speed: 0.3 + Math.random() * 0.5,
      size : 1.5 + Math.random() * 3,
      phase: Math.random() * Math.PI * 2
    }));

    function renderSparkles(ts) {
      const s = SCALE;
      SPARKS.forEach(sp => {
        const a = sp.angle + ts * 0.00035 * sp.speed;
        const x = CX + Math.cos(a) * sp.dist * s * (0.88 + 0.12 * Math.sin(ts*0.002 + sp.phase));
        const y = CY + Math.sin(a) * sp.dist * s * 0.68 - 10 * s;
        const blink = 0.35 + 0.65 * Math.abs(Math.sin(ts * 0.003 + sp.phase));
        ctx.save();
        ctx.shadowColor = '#ffe066'; ctx.shadowBlur = 8;
        ctx.fillStyle   = `rgba(255,230,80,${blink * fillAlpha})`;
        ctx.beginPath();
        ctx.arc(x, y, sp.size * (0.6 + 0.4 * blink), 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      });
    }

    function render(ts) {
      ctx.clearRect(0, 0, W, H);

      // Background
      ctx.save();
      ctx.fillStyle = 'rgba(6,2,18,0.72)';
      ctx.beginPath(); ctx.roundRect(0, 0, W, H, 18); ctx.fill();
      ctx.restore();

      // Warm rim
      ctx.save();
      ctx.strokeStyle = 'rgba(255,180,80,0.2)'; ctx.lineWidth = 1;
      ctx.beginPath(); ctx.roundRect(0, 0, W, H, 18); ctx.stroke();
      ctx.restore();

      // Background stars (scale positions)
      BG_STARS.forEach(s => {
        const a = 0.15 + 0.35 * Math.abs(Math.sin(ts * 0.0008 + s.p));
        ctx.fillStyle = `rgba(255,240,200,${a})`;
        ctx.beginPath();
        ctx.arc(s.x * SCALE, s.y * SCALE, s.r, 0, Math.PI * 2);
        ctx.fill();
      });

      drawHeartGuide(1);

      if (done) { fillAlpha = Math.min(fillAlpha + 0.012, 1); drawHeartFill(fillAlpha); }

      // Connecting lines
      if (connected.length >= 2) {
        ctx.save();
        ctx.beginPath();
        connected.forEach((ci, i) => {
          const s = STARS[ci];
          i === 0 ? ctx.moveTo(s.x, s.y) : ctx.lineTo(s.x, s.y);
        });
        ctx.strokeStyle = 'rgba(255,220,60,0.88)';
        ctx.lineWidth   = 2.2;
        ctx.lineJoin    = 'round'; ctx.lineCap = 'round';
        ctx.shadowColor = 'rgba(255,190,30,0.8)'; ctx.shadowBlur = 10;
        ctx.stroke();
        ctx.restore();
      }

      // Closing line
      if (done && connected.length === 12) {
        const s0 = STARS[0], sL = STARS[11];
        ctx.save();
        ctx.beginPath(); ctx.moveTo(sL.x, sL.y); ctx.lineTo(s0.x, s0.y);
        ctx.strokeStyle = 'rgba(255,220,60,0.92)';
        ctx.lineWidth   = 2.2;
        ctx.shadowColor = 'rgba(255,190,30,0.9)'; ctx.shadowBlur = 12;
        ctx.stroke();
        ctx.restore();
      }

      // Stars
      const pulse = 0.5 + 0.5 * Math.sin(ts * 0.0025);
      const sr = SR();
      STARS.forEach((s, i) => {
        const isConnected = connected.includes(i);
        const isNext      = i === nextIdx && !done;
        const isWrong     = i === wrongIdx;

        ctx.save();
        if (isConnected || done) {
          ctx.shadowColor = '#ffe066'; ctx.shadowBlur = done ? 24 : 16;
        } else if (isNext) {
          ctx.shadowColor = '#ffcc33'; ctx.shadowBlur = 10 + 14 * pulse;
        }

        const r = isConnected ? sr+3 : isNext ? sr+2 : sr;
        starPath(s.x, s.y, r);
        ctx.fillStyle = isWrong     ? '#ff3311'
                      : isConnected ? '#ffee66'
                      : isNext      ? `rgba(255,225,80,${0.6+0.4*pulse})`
                      : 'rgba(255,210,130,0.48)';
        ctx.fill();

        if (isConnected || done) {
          ctx.beginPath(); ctx.arc(s.x, s.y, r+5, 0, Math.PI*2);
          ctx.strokeStyle = `rgba(255,230,80,${done ? 0.55 : 0.35})`;
          ctx.lineWidth = 1; ctx.stroke();
        }
        if (isNext) {
          ctx.beginPath(); ctx.arc(s.x, s.y, r+6+4*pulse, 0, Math.PI*2);
          ctx.strokeStyle = `rgba(255,220,60,${0.5*pulse})`;
          ctx.lineWidth = 1.2; ctx.stroke();
        }
        ctx.restore();

        ctx.save();
        const fontSize = Math.max(7, Math.round((isConnected||isNext ? 11 : 9) * SCALE));
        ctx.font = `bold ${fontSize}px sans-serif`;
        ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
        ctx.fillStyle = isConnected ? '#fff8ef'
                      : isNext      ? 'rgba(255,248,180,1)'
                      : 'rgba(255,225,160,0.75)';
        ctx.fillText(i+1, s.x, s.y);
        ctx.restore();
      });

      if (done) renderSparkles(ts);
      requestAnimationFrame(render);
    }
    requestAnimationFrame(render);

    function getXY(clientX, clientY) {
      const r = canvas.getBoundingClientRect();
      return {
        x: (clientX - r.left) * (W / r.width),
        y: (clientY - r.top)  * (H / r.height)
      };
    }

    function handleTap(cx, cy) {
      if (done) return;
      const { x, y } = getXY(cx, cy);
      let best=-1, bestD=HIT();
      STARS.forEach((s,i)=>{ const d=Math.hypot(s.x-x,s.y-y); if(d<bestD){bestD=d;best=i;} });
      if (best===-1) return;

      if (best===nextIdx) {
        connected.push(best); nextIdx++;
        if (nextIdx<12) {
          hint.textContent='Відстань між нами тане у зоряному сяйві';
        } else {
          done=true; goBtn.disabled=false; goBtn.classList.add('unlocked');
          hint.textContent='\u2605 Зорі склалися саме так, як і мали';
        }
      } else {
        wrongIdx=best; clearTimeout(wrongTimer);
        wrongTimer=setTimeout(()=>{wrongIdx=-1;},500);
        hint.textContent=`Ні \u2014 це зірка ${best+1}. Знайди ${nextIdx+1}`;
        setTimeout(()=>{
          if(!done) hint.textContent=nextIdx===0
            ?'Допоможи цим зорям знайти шлях одна до одної'
            :'Відстань між нами тане у зоряному сяйві';
        },1800);
      }
    }

    canvas.addEventListener('click',      e=>handleTap(e.clientX,e.clientY));
    canvas.addEventListener('touchstart', e=>{
      e.preventDefault(); handleTap(e.touches[0].clientX,e.touches[0].clientY);
    },{passive:false});
    goBtn.addEventListener('click',()=>{ window.location.href='animation.htm'; });

    // Handle orientation change / resize
    window.addEventListener('resize', () => {
      initSize();
      STARS = buildStars();
    });
  });
  </script>

  <script>
  /* ── Scroll-driven warm → pink → night sky transition v2 ── */
  (function () {

    const WARM = {
      top:  [26,5,51], mid1:[107,26,58], mid2:[192,57,43], mid3:[232,98,42],
      mid4: [240,165,0], mid5:[247,201,72], mid6:[244,162,97], mid7:[231,111,81],
      mid8: [193,68,14], bot:[123,26,58]
    };

    /* Rich rose-pink twilight matching the raccoon/cat artwork */
    const PINK = {
      top:  [45,10,70], mid1:[120,25,90], mid2:[180,40,100], mid3:[210,60,120],
      mid4: [220,80,130], mid5:[200,70,110], mid6:[170,55,95], mid7:[130,45,85],
      mid8: [80,25,70], bot:[40,10,55]
    };

    const NIGHT = {
      top:  [6,10,30], mid1:[11,28,55], mid2:[18,50,78], mid3:[25,60,95],
      mid4: [35,75,110], mid5:[57,100,127], mid6:[45,85,118], mid7:[30,65,100],
      mid8: [18,45,75], bot:[8,18,42]
    };

    function lerp(a, b, t) { return a + (b - a) * t; }
    function lerpRGB(ca, cb, t) {
      return [Math.round(lerp(ca[0],cb[0],t)), Math.round(lerp(ca[1],cb[1],t)), Math.round(lerp(ca[2],cb[2],t))];
    }
    function rgb(c) { return `rgb(${c[0]},${c[1]},${c[2]})`; }
    function smoothstep(t) { return t * t * (3 - 2 * t); }

    function getPalette(t) {
      const keys = Object.keys(WARM);
      const result = {};
      if (t <= 0.45) {
        const s = smoothstep(t / 0.45);
        keys.forEach(k => { result[k] = lerpRGB(WARM[k], PINK[k], s); });
      } else {
        const s = smoothstep((t - 0.45) / 0.55);
        keys.forEach(k => { result[k] = lerpRGB(PINK[k], NIGHT[k], s); });
      }
      return result;
    }

    function applyProgress(t) {
      const root = document.documentElement;
      const palette = getPalette(t);
      Object.keys(palette).forEach(k => root.style.setProperty(`--sky-${k}`, rgb(palette[k])));

      /* Sun fades out by t=0.5, moon fades in from t=0.45 */
      root.style.setProperty('--sun-opacity',  Math.max(0, 1 - t * 2).toFixed(3));
      root.style.setProperty('--star-opacity', Math.min(1, Math.max(0, (t - 0.45) * 2.2)).toFixed(3));

      /* Night stars appear from t=0.35 (during pink phase) */
      document.querySelectorAll('.night-star').forEach(el => {
        const fade = Math.min(1, Math.max(0, (t - 0.35) / 0.4));
        el.style.opacity = (fade * parseFloat(el.dataset.maxOpacity || 0.9)).toFixed(3);
      });

      /* Card night-mode from t=0.65 */
      document.querySelectorAll('.glass-card').forEach(c => c.classList.toggle('night-mode', t > 0.65));

      /* Bubble tint: gold → rose → blue-white */
      document.querySelectorAll('.bubble').forEach(b => {
        let r, g, bl;
        if (t <= 0.45) {
          const s = t / 0.45;
          r = 255; g = Math.round(lerp(220,160,s)); bl = Math.round(lerp(150,200,s));
        } else {
          const s = (t - 0.45) / 0.55;
          r = Math.round(lerp(255,180,s)); g = Math.round(lerp(160,210,s)); bl = Math.round(lerp(200,255,s));
        }
        b.style.background = `radial-gradient(circle at 35% 35%,
          rgba(255,255,255,0.55) 0%, rgba(${r},${g},${bl},0.15) 40%,
          rgba(${r},${g},${bl},0.08) 70%, transparent 100%)`;
      });
    }

    function createNightStars() {
      if (document.querySelector('.night-star')) return;
      for (let i = 0; i < 55; i++) {
        const el = document.createElement('div');
        el.className = 'night-star';
        const size = 1 + Math.random() * 2.5;
        el.dataset.maxOpacity = (0.4 + Math.random() * 0.55).toFixed(2);
        Object.assign(el.style, {
          width:  size + 'px', height: size + 'px',
          left:   (Math.random() * 100) + '%', top: (Math.random() * 90) + '%',
          animationDuration: (2 + Math.random() * 4).toFixed(1) + 's',
          animationDelay:    '-' + (Math.random() * 4).toFixed(1) + 's',
          opacity: '0'
        });
        document.body.appendChild(el);
      }
    }

    function onScroll() {
      const scrollTop = window.scrollY || document.documentElement.scrollTop;
      const maxScroll = document.documentElement.scrollHeight - window.innerHeight;
      const t = Math.max(0, Math.min(1, (scrollTop / maxScroll - 0.10) / 0.80));
      applyProgress(t);
    }

    document.addEventListener('DOMContentLoaded', () => {
      createNightStars();
      applyProgress(0);
      window.addEventListener('scroll', onScroll, { passive: true });
    });
  })();
  </script>

</body>
</html>
